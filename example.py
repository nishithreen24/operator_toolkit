from operator_toolkit import Kets, Bras, Operators
import numpy as np

sigx = Operators(data = np.array(([0, 1], [1, 0])))
sigy = Operators(data = np.array(([0, -1j], [1j, 0])))
sigz = Operators(data = np.array(([1, 0], [0, -1])))
I = Operators(data = np.eye(2))

ket0 = Kets([1, 0])
ket1 = Kets([0, 1])
psi = np.sqrt(1/2)*(ket0 + ket1)


iket0 = Kets([1j, 0])
iket1 = Kets([0, 1j])

bra0 = Kets.dagger(iket0)
bra1 = Kets.dagger(iket1)

bra = Bras([1, 0, 0])
ket = Kets([1, 0, 0])
#print(sigx.operator.shape[1])
#print(psi.ket.shape[0])
#print((sigx@ket1).ket)
#print(Kets.dagger(iket0).bra)
#print(len(ket0.ket))
#print(Kets.dagger(ket0).bra.shape[1])
#print(ket0@Kets.dagger(ket0))
#print(ket0 @ ket0)
#print(ket0 * ket0)
#print(iket0 @ bra0)
#print(iket0@iket0)
#print(bra0@iket0)
#print(sigx-sigy)
#print(bra0-bra)
#print(ket0-ket)
#print(ket.ket, bra.bra)
#print(ket.ket*5)
#print(5*bra.bra)
#print(bra0 @ sigz)
#print(bra0 * bra0)
#print(Bras.dagger(bra0))
#print(bra1 @ ket1)
#print(iket1 @ ket1)
#print(sigx + sigy)
sig = Operators(data = np.array(([1, 1j], [0, 1j])))
#print(sig.dagger())
#print(sigx.isHermitian())
#print((sigx*sigy)@(ket0*ket1))
#print((sigx@ket0) * (sigy@ket1))
#print((sigy*1j).isHermitian())
#print((sigy*1j).isUnitary())
U = Operators(data = np.array(([0, 1], [-1, 0])))
#print(U.isHermitian())
#print(U.isUnitary())
N = Operators(data = np.array(([1, 0], [0, 2])))
#print(N.isHermitian())
#print(N.isUnitary())
#print(N.isNormal())
#print((2*U).isHermitian())
#print((2*U).isUnitary())
#print((2*U).isNormal())
A = Operators(np.array(([2, 1], [1, 2])))
P, D = sigx.spectral_decomposition()
D = Operators(D)
P = Operators(P)
#print(D.operator)
#print(P.operator)
#print((P @ D @ P.dagger()).operator)
#phi = Bras([1, 0, -1])
#print((phi*5).bra)
#print((5*phi).bra)
#print((bra0 * bra).bra)
#print(bra0.rho().operator)
#print(len((Kets.tensor_product(ket0, ket1, iket0, iket1)).ket))
#print((ket0*ket1*iket1*iket0).ket)
#print(I.trace())
